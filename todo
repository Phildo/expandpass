- unicode
- validate smartly (know to skip whole groups of modifications/etc... if guaranteed to not succeed) [HARD]
- --unroll #: notice if subgroup is something complicated, but results in < #(~100) possibilities, and expand to enumerated group (quicker runtime(?))
- parallelize (currently not super necessary- ~1M lines/s)
- pre-defined modification gamuts (alpha, alphanumeric, etc...)
- user defined modification gamuts (for easy reuse)
- user-defined smart substitution gamuts
- formal tests
- current codebase is pretty loose with (SEED-OPTIMIZATION BASED) memory leaks (as in, rather than recursively delete redundant groups/modifications/etc..., just leaves for OS). would be nice to formalize.
- current codebase doesn't have ultra-strict error checking (for example- if you have a password > 500 chars, it might crash)

