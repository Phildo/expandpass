- unicode
- validate smartly (know to skip whole groups of modifications/etc... if guaranteed to not succeed) [HARD]
- parallelize (currently not super necessary- ~1M lines/s)
- pre-defined modification gamuts (alpha, alphanumeric, etc...)
- user defined modification gamuts (for easy reuse)
- user-defined smart substitution gamuts
- formal tests
- current codebase is pretty loose with (SEED-OPTIMIZATION BASED) memory leaks (as in, rather than recursively delete redundant groups/modifications/etc..., it just leaves cleanup for OS). would be nice to formalize. (however- because it really only is in the seed optimization phase, which relies on very limited memory amounts for a non-recurring amount of time, it's actually not a huge problem)
- current codebase doesn't have ultra-strict error checking (for example- if you have a password > 500 chars, it might crash)

